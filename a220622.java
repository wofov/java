import java.util.Scanner;

public class a220622 {

	public static void main(String[] args) {
		String newdata ="";
		newdata +=this.ar1[w]+",";//대충 반복문 돌아간다. 
		String ar2[]=newdata.split(",");//새로운 배열 만드는 스플릿
		
		Thread my = new test1();
		Thread my2 =new test2();//쓰레드 변수 선언
		my.start();
		my2.start();//start로 시작 run으로 받아들임. 
		class test1 extends Thread{//꼭 extends를 사용한다 
			@Override
		    public void run()
	    class test2 extends Thread{
			@Override
			public void run()
			
		//추상 클래스 : 외부에서 로드가 절대 안됨, 자체 실행도 안됨
		@Override // > 추상 abstract 사용 하면 꼭 오버라이드 사용;★★인터페이스도!!
		abstract class box//>박스 추상 클래스
		class ab extends box//extends 사용 
		
		/*
		 Arrays.sort 배열 오름차순 정렬(숫자,한글,영문) 관계없이 가능
		 단, 영문일 경우 대문재가 먼저 오른차순으로 정렬됨 A,a
		 int number_data[]= {5,7,1,4,9,2};
     	 Arrays.sort(number_data);//오름차순
     	 
     	 Collection.sort(list)>이건 배열 리스트 오름차순 알지?
		 */
		//abstract와 인터페이스 모두 static 사용 할 수 있음. 
		//abstract는 default를 사용하지 못함(public 기본설정)
		
		//인터페이스
		//필드에 자료형을 비어있는 값을 사용할 경우 적용 자체가 안됨.
		//무조건 값을 정해놔야함. 인터페이스 안에 public에서 this를 사용 못하지만
		//default에서는 this사용 가능
		class ln implements inter1,inter2// implements와 , 를 이용해서 인터페이스 데려올수있다.
		//아예 다른 인터페이스를 , 통해 로드 가능. 
		public interface inter{
				default String box3() {//getter
					//인터페이스에는 default를 선언하면 연산 메소드를 사용함
					return null;}
				public String names()//인터페이스 안에 public사용하연 연산메소드 안됨
			
	    interface inter1 extends inter{ 
				//인터페이스에 extends로 부모 인터페이스를 로드할수있다. 
				}
				
		//다른 패키지 		
		//package Ab2;
		import Ab.method_1;
		public class ab2_method extends Ab.method_1 {//public class는 한번밖에 사용 못한다.
				public static void main(String[] args) {
					Ab.method_1 at = new Ab.method_1();
					at.main(args);//메인 클래스 로드
					at.recall();// public 메소드 실행 //private는 로드 불가 
					at.name();
					}
				}
		//package Ab;
		public class method_1{//package Ab2에서 import할 수 있도록 하며,
			//외부 클래스에서도 동일하게 가져온다. 
			public void recall() {//다른 패키지 보낼때 꼭 public 작성하기.
			protected static void name() {//패키지 넘길때 protected 사용시 static사용 하기 
			public static void main(String[] args) {
				//원래는 값이 있던건 sysout 라라라
			}
			
			Integer num[]= {15,22,37,8,11,19,41};
			ArrayList<Integer> a= new ArrayList<Integer>(Arrays.asList(num));
			//리스트 기본 배열 넘기기. int는 integer로 String은 그냥 String입니다. 
			//리스트로 1~10까지 숫자중 짝수 삭제 한다고 할때
			//더블 반복문 쓰는 이유가 조건 맞을떄 remove 쓰면 배열 숫자가 변하니까. ㅇㅋ?
			Collections.sort(list); // 오름차순 쇼트 하는 법 
			LinkedList<Integer> list = new LinkedList<>();
			ArrayList list = new ArrayList();//자료형이 없는 배열
			Object k = list.get(ww);
			int numbers = Integer.parseInt(k.toString());
			//해당 매게타입을 문자화 하여 pareInt를 다시 검증함.
			int ck = Integer.valueOf((int)call[1])//call이 문자 일때 오류
			String ck = String.valueOf((String)call[w]);//call이 숫자 일떄 오류
			
			try {
				int number = Integer.parseInt(user);//숫자 외에 입력했을 때 오류 발생 그리고 캐치로 이동
				catch(Exception a1) {//오류가 발생햇을경우 작동되는 파트
					System.out.println("숫자만 입력");
			//그리고 반복문 안에 try catch문 생각 먼저기기기
		
			//int word = id[4].length();//★★length() < 단어 글자 수 괄호 꼭
			System.out.println(Arrays.toString(user_menu));//일반 배열 출력
			String[] names = new String[a]; //값이 없는 배열 
			
			mother m = new mother(30, 50);
			mother.child mm = m.new child();
			mm.mini();
			//자식 클래스 안에서 mother.this.a1
			if(a==null) {//null은 equals사용 안된다.★★★
		
			if(this.abc.get(0).indexOf(email2)!=-1) {
		    // 인덱스오브 -1은 해당 값이 없음. 그 외의 모든 정수는 값이 있음.
				//indexOf(찾을 값)★★★
			class inherit1{
			private String nm;//inherit1 해당 부분에서만 작동
			//extends 해도 private사용 못함
			protected String pw;//inherit1, inherit2에서 모두 작동 되도록 하여, 외부에서 로드 못함
			
			
			
			
			
			
			
			
			
			
}
}